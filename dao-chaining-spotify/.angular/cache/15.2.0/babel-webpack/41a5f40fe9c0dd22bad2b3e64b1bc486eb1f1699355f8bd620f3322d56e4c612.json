{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/trach/DAO/dao-chaining-spotify/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst cacheUtils = require('./cache-utils.js');\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware');\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e'];\nmodule.exports = createBlockCacheMiddleware;\nfunction createBlockCacheMiddleware(opts = {}) {\n  // validate options\n  const {\n    blockTracker\n  } = opts;\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified');\n\n  // create caching strategies\n  const blockCache = new BlockCacheStrategy();\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache\n  };\n  return createAsyncMiddleware( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (req, res, next) {\n      // allow cach to be skipped if so specified\n      if (req.skipCache) {\n        return next();\n      }\n      // check type and matching strategy\n      const type = cacheUtils.cacheTypeForPayload(req);\n      const strategy = strategies[type];\n      // If there's no strategy in place, pass it down the chain.\n      if (!strategy) {\n        return next();\n      }\n      // If the strategy can't cache this request, ignore it.\n      if (!strategy.canCacheRequest(req)) {\n        return next();\n      }\n\n      // get block reference (number or keyword)\n      let blockTag = cacheUtils.blockTagForPayload(req);\n      if (!blockTag) blockTag = 'latest';\n\n      // get exact block number\n      let requestedBlockNumber;\n      if (blockTag === 'earliest') {\n        // this just exists for symmetry with \"latest\"\n        requestedBlockNumber = '0x00';\n      } else if (blockTag === 'latest') {\n        // fetch latest block number\n        const latestBlockNumber = yield blockTracker.getLatestBlock();\n        // clear all cache before latest block\n        blockCache.clearBefore(latestBlockNumber);\n        requestedBlockNumber = latestBlockNumber;\n      } else {\n        // We have a hex number\n        requestedBlockNumber = blockTag;\n      }\n\n      // end on a hit, continue on a miss\n      const cacheResult = yield strategy.get(req, requestedBlockNumber);\n      if (cacheResult === undefined) {\n        // cache miss\n        // wait for other middleware to handle request\n        yield next();\n        // add result to cache\n        yield strategy.set(req, requestedBlockNumber, res.result);\n      } else {\n        // fill in result from cache\n        res.result = cacheResult;\n      }\n    });\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n}\n\n//\n// Cache Strategies\n//\n\nclass BlockCacheStrategy {\n  constructor() {\n    this.cache = {};\n  }\n  getBlockCacheForPayload(payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16);\n    let blockCache = this.cache[blockNumber];\n    // create new cache if necesary\n    if (!blockCache) {\n      const newCache = {};\n      this.cache[blockNumber] = newCache;\n      blockCache = newCache;\n    }\n    return blockCache;\n  }\n  get(payload, requestedBlockNumber) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // lookup block cache\n      const blockCache = _this.getBlockCacheForPayload(payload, requestedBlockNumber);\n      if (!blockCache) return;\n      // lookup payload in block cache\n      const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n      const cached = blockCache[identifier];\n      // may be undefined\n      return cached;\n    })();\n  }\n  set(payload, requestedBlockNumber, result) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // check if we can cached this result\n      const canCache = _this2.canCacheResult(payload, result);\n      if (!canCache) return;\n      // set the value in the cache\n      const blockCache = _this2.getBlockCacheForPayload(payload, requestedBlockNumber);\n      const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n      blockCache[identifier] = result;\n    })();\n  }\n  canCacheRequest(payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false;\n    }\n    // check blockTag\n    const blockTag = cacheUtils.blockTagForPayload(payload);\n    if (blockTag === 'pending') {\n      return false;\n    }\n    // can be cached\n    return true;\n  }\n  canCacheResult(payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return;\n    // check if transactions have block reference before caching\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false;\n      }\n    }\n    // otherwise true\n    return true;\n  }\n\n  // removes all block caches with block number lower than `oldBlockHex`\n  clearBefore(oldBlockHex) {\n    const self = this;\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16);\n    // clear old caches\n    Object.keys(self.cache).map(Number).filter(num => num < oldBlockNumber).forEach(num => delete self.cache[num]);\n  }\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}