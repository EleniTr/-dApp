{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from \"@angular/common/http\";\nimport { of, throwError } from \"rxjs\";\nimport { delay, mergeMap, materialize, dematerialize } from \"rxjs/operators\";\nimport * as i0 from \"@angular/core\";\n// array in local storage for registered users\nlet users = JSON.parse(localStorage.getItem(\"users\")) || [];\n// const users: User[] = usersData;\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      // wrap in delayed observable to simulate server api call\n      return of(null).pipe(mergeMap(handleRoute)).pipe(materialize()) // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648)\n      .pipe(delay(500)).pipe(dematerialize());\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith(\"/users/authenticate\") && method === \"POST\":\n            return authenticate();\n          case url.endsWith(\"/users/signup\") && method === \"POST\":\n            return register();\n          case url.endsWith(\"/users\") && method === \"GET\":\n            return getUsers();\n          case url.match(/\\/users\\/\\d+$/) && method === \"GET\":\n            return getUserById();\n          case url.match(/\\/users\\/\\d+$/) && method === \"PUT\":\n            return updateUser();\n          case url.match(/\\/users\\/\\d+$/) && method === \"DELETE\":\n            return deleteUser();\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      }\n      // route functions\n      function authenticate() {\n        const {\n          username,\n          password\n        } = body;\n        const user = users.find(x => x.username === username && x.password === password);\n        if (!user) return error(\"Username or password is incorrect\");\n        return ok({\n          id: user.id,\n          role: user.role,\n          username: user.username,\n          firstName: user.firstName,\n          lastName: user.lastName,\n          token: \"fake-jwt-token\"\n        });\n      }\n      function register() {\n        const user = body;\n        if (users.find(x => x.username === user.username)) {\n          return error('Username \"' + user.username + '\" is already taken');\n        }\n        user.id = users.length ? Math.max(...users.map(x => x.id)) + 1 : 1;\n        users.push(user);\n        localStorage.setItem(\"users\", JSON.stringify(users));\n        return ok();\n      }\n      function getUsers() {\n        if (!isLoggedIn()) return unauthorized();\n        return ok(users);\n      }\n      function getUserById() {\n        if (!isLoggedIn()) return unauthorized();\n        const user = users.find(x => x.id === idFromUrl());\n        return ok(user);\n      }\n      function updateUser() {\n        if (!isLoggedIn()) return unauthorized();\n        let params = body;\n        let user = users.find(x => x.id === idFromUrl());\n        // only update password if entered\n        if (!params.password) {\n          delete params.password;\n        }\n        // update and save user\n        Object.assign(user, params);\n        localStorage.setItem(\"users\", JSON.stringify(users));\n        return ok();\n      }\n      function deleteUser() {\n        if (!isLoggedIn()) return unauthorized();\n        users = users.filter(x => x.id !== idFromUrl());\n        localStorage.setItem(\"users\", JSON.stringify(users));\n        return ok();\n      }\n      // helper functions\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        }));\n      }\n      function error(message) {\n        return throwError({\n          error: {\n            message\n          }\n        });\n      }\n      function unauthorized() {\n        return throwError({\n          status: 401,\n          error: {\n            message: \"Unauthorised\"\n          }\n        });\n      }\n      // function isLoggedIn() {\n      //   this.loggedInUser = authenticate();\n      //   if (this.loggedInUser.role != \"admin\") {\n      //     return (\n      //       headers.get(\"Authorization\") === `Basic ${window.btoa(\"test:test\")}`\n      //     );\n      //   } else {\n      //     return (\n      //       headers.get(\"Authorization\") === `Basic ${window.btoa(\"admin:admin\")}`\n      //     );\n      //   }\n      // }\n      function isLoggedIn() {\n        return headers.get(\"Authorization\") === \"Bearer fake-jwt-token\";\n      }\n      function idFromUrl() {\n        const urlParts = url.split(\"/\");\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n    }\n  }\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)();\n  };\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport let fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}