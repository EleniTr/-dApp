{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Directive, Input, NgModule, createComponent, TemplateRef, Component, InjectionToken, inject, Injector, ApplicationRef, EnvironmentInjector } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nlet TeleportService = /*#__PURE__*/(() => {\n  class TeleportService {\n    constructor() {\n      this.outlets = new BehaviorSubject('');\n      this.asObservable = this.outlets.asObservable();\n      this.ports = new Map();\n    }\n    outlet$(name) {\n      return this.asObservable.pipe(filter(current => current === name), map(name => this.ports.get(name)));\n    }\n    newOutlet(name) {\n      this.outlets.next(name);\n    }\n  }\n  TeleportService.ɵfac = function TeleportService_Factory(t) {\n    return new (t || TeleportService)();\n  };\n  TeleportService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TeleportService,\n    factory: TeleportService.ɵfac,\n    providedIn: 'root'\n  });\n  return TeleportService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TeleportOutletDirective = /*#__PURE__*/(() => {\n  class TeleportOutletDirective {\n    constructor(vcr, service) {\n      this.vcr = vcr;\n      this.service = service;\n    }\n    ngOnChanges(changes) {\n      // The `teleportOutlet` might be `null|undefined`, but we don't want nullable values to be used\n      // as keys for the `ports` map.\n      if (changes.teleportOutlet && typeof this.teleportOutlet === 'string') {\n        this.service.ports.set(this.teleportOutlet, this.vcr);\n        this.service.newOutlet(this.teleportOutlet);\n      }\n    }\n    ngOnDestroy() {\n      this.service.ports.delete(this.teleportOutlet);\n    }\n  }\n  TeleportOutletDirective.ɵfac = function TeleportOutletDirective_Factory(t) {\n    return new (t || TeleportOutletDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(TeleportService));\n  };\n  TeleportOutletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TeleportOutletDirective,\n    selectors: [[\"\", \"teleportOutlet\", \"\"]],\n    inputs: {\n      teleportOutlet: \"teleportOutlet\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TeleportOutletDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TeleportDirective = /*#__PURE__*/(() => {\n  class TeleportDirective {\n    constructor(tpl, service) {\n      this.tpl = tpl;\n      this.service = service;\n      this.subscription = null;\n    }\n    ngOnChanges(changes) {\n      if (changes.teleportTo && typeof this.teleportTo === 'string') {\n        this.dispose();\n        this.subscription = this.service.outlet$(this.teleportTo).subscribe(outlet => {\n          if (outlet) {\n            this.viewRef = outlet.createEmbeddedView(this.tpl);\n          }\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.dispose();\n    }\n    dispose() {\n      this.subscription?.unsubscribe();\n      this.subscription = null;\n      this.viewRef?.destroy();\n    }\n  }\n  TeleportDirective.ɵfac = function TeleportDirective_Factory(t) {\n    return new (t || TeleportDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(TeleportService));\n  };\n  TeleportDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TeleportDirective,\n    selectors: [[\"\", \"teleportTo\", \"\"]],\n    inputs: {\n      teleportTo: \"teleportTo\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TeleportDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TeleportModule = /*#__PURE__*/(() => {\n  class TeleportModule {}\n  TeleportModule.ɵfac = function TeleportModule_Factory(t) {\n    return new (t || TeleportModule)();\n  };\n  TeleportModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TeleportModule\n  });\n  TeleportModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return TeleportModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass CompRef {\n  constructor(options) {\n    this.options = options;\n    if (options.vcr) {\n      this.ref = options.vcr.createComponent(options.component, {\n        index: options.vcr.length,\n        injector: options.injector || options.vcr.injector\n      });\n    } else {\n      this.ref = createComponent(options.component, {\n        elementInjector: options.injector,\n        environmentInjector: options.environmentInjector\n      });\n      options.appRef.attachView(this.ref.hostView);\n    }\n  }\n  setInput(input, value) {\n    this.ref.instance[input] = value;\n    return this;\n  }\n  setInputs(inputs) {\n    Object.keys(inputs).forEach(input => {\n      this.ref.instance[input] = inputs[input];\n    });\n    return this;\n  }\n  detectChanges() {\n    this.ref.hostView.detectChanges();\n    return this;\n  }\n  appendTo(container) {\n    container.appendChild(this.getElement());\n    return this;\n  }\n  removeFrom(container) {\n    container.removeChild(this.getElement());\n    return this;\n  }\n  getRawContent() {\n    return this.getElement().outerHTML;\n  }\n  getElement() {\n    return this.ref.location.nativeElement;\n  }\n  destroy() {\n    this.ref.destroy();\n    !this.options.vcr && this.options.appRef.detachView(this.ref.hostView);\n    this.ref = null;\n  }\n}\nfunction isTemplateRef(value) {\n  return value instanceof TemplateRef;\n}\nfunction isComponent(value) {\n  return typeof value === 'function';\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\nfunction getViewRef(value) {\n  return value instanceof CompRef ? value.ref.hostView : value.ref;\n}\nlet DynamicViewComponent = /*#__PURE__*/(() => {\n  class DynamicViewComponent {}\n  DynamicViewComponent.ɵfac = function DynamicViewComponent_Factory(t) {\n    return new (t || DynamicViewComponent)();\n  };\n  DynamicViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DynamicViewComponent,\n    selectors: [[\"dynamic-view\"]],\n    inputs: {\n      content: \"content\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"innerHTML\"]],\n    template: function DynamicViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", ctx.content, i0.ɵɵsanitizeHtml);\n      }\n    },\n    encapsulation: 2\n  });\n  return DynamicViewComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass TplRef {\n  constructor(args) {\n    this.args = args;\n    if (this.args.vcr) {\n      this.ref = this.args.vcr.createEmbeddedView(this.args.tpl, this.args.context || {}, {\n        injector: args.injector\n      });\n      this.ref.detectChanges();\n    } else {\n      this.ref = this.args.tpl.createEmbeddedView(this.args.context || {}, args.injector);\n      this.ref.detectChanges();\n      this.args.appRef.attachView(this.ref);\n    }\n  }\n  detectChanges() {\n    this.ref.detectChanges();\n  }\n  getElement() {\n    const rootNodes = this.ref.rootNodes;\n    if (rootNodes.length === 1 && rootNodes[0] === Node.ELEMENT_NODE) {\n      this.element = rootNodes[0];\n    } else {\n      this.element = document.createElement('div');\n      this.element.append(...rootNodes);\n    }\n    return this.element;\n  }\n  destroy() {\n    if (this.ref.rootNodes[0] !== 1) {\n      this.element?.parentNode.removeChild(this.element);\n      this.element = null;\n    }\n    if (!this.args.vcr) {\n      this.args.appRef.detachView(this.ref);\n    }\n    this.ref.destroy();\n    this.ref = null;\n  }\n}\nclass StringRef {\n  constructor(value) {\n    this.value = value;\n  }\n  getElement() {\n    return this.value;\n  }\n  detectChanges() {}\n  destroy() {}\n}\nconst VIEW_CONTEXT = new InjectionToken('Component context');\nlet ViewService = /*#__PURE__*/(() => {\n  class ViewService {\n    constructor() {\n      this.injector = inject(Injector);\n      this.appRef = inject(ApplicationRef);\n      this.environmentInjector = inject(EnvironmentInjector);\n    }\n    createComponent(component, options = {}) {\n      let injector = options.injector || this.injector;\n      if (options.context) {\n        injector = Injector.create({\n          providers: [{\n            provide: VIEW_CONTEXT,\n            useValue: options.context\n          }],\n          parent: injector\n        });\n      }\n      return new CompRef({\n        component,\n        vcr: options.vcr,\n        injector,\n        appRef: this.appRef,\n        environmentInjector: options.environmentInjector || this.environmentInjector\n      });\n    }\n    createTemplate(tpl, options = {}) {\n      return new TplRef({\n        vcr: options.vcr,\n        appRef: this.appRef,\n        tpl,\n        context: options.context,\n        injector: options.injector\n      });\n    }\n    createView(content, viewOptions = {}) {\n      if (isTemplateRef(content)) {\n        return this.createTemplate(content, viewOptions);\n      } else if (isComponent(content)) {\n        return this.createComponent(content, viewOptions);\n      } else if (isString(content)) {\n        return new StringRef(content);\n      } else {\n        throw 'Type of content is not supported';\n      }\n    }\n  }\n  ViewService.ɵfac = function ViewService_Factory(t) {\n    return new (t || ViewService)();\n  };\n  ViewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ViewService,\n    factory: ViewService.ɵfac,\n    providedIn: 'root'\n  });\n  return ViewService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction injectViewContext() {\n  return inject(VIEW_CONTEXT);\n}\nlet DynamicViewDirective = /*#__PURE__*/(() => {\n  class DynamicViewDirective {\n    constructor(defaultTpl, vcr, viewService) {\n      this.defaultTpl = defaultTpl;\n      this.vcr = vcr;\n      this.viewService = viewService;\n    }\n    ngOnInit() {\n      this.resolveContentType();\n    }\n    ngOnChanges(changes) {\n      if (changes.view && !changes.view.isFirstChange()) {\n        this.resolveContentType();\n      }\n    }\n    resolveContentType() {\n      this.viewRef?.destroy();\n      if (isString(this.view)) {\n        this.viewRef = this.viewService.createComponent(DynamicViewComponent, {\n          vcr: this.vcr,\n          injector: this.injector\n        });\n        this.viewRef.setInput('content', this.view).detectChanges();\n      } else {\n        this.viewRef = this.viewService.createView(this.view || this.defaultTpl, {\n          vcr: this.vcr,\n          injector: this.injector ?? this.vcr.injector,\n          context: this.context\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.viewRef?.destroy();\n    }\n  }\n  DynamicViewDirective.ɵfac = function DynamicViewDirective_Factory(t) {\n    return new (t || DynamicViewDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(ViewService));\n  };\n  DynamicViewDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DynamicViewDirective,\n    selectors: [[\"\", \"dynamicView\", \"\"]],\n    inputs: {\n      view: [\"dynamicView\", \"view\"],\n      injector: [\"dynamicViewInjector\", \"injector\"],\n      context: [\"dynamicViewContext\", \"context\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return DynamicViewDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DynamicViewModule = /*#__PURE__*/(() => {\n  class DynamicViewModule {}\n  DynamicViewModule.ɵfac = function DynamicViewModule_Factory(t) {\n    return new (t || DynamicViewModule)();\n  };\n  DynamicViewModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DynamicViewModule\n  });\n  DynamicViewModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return DynamicViewModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of overview\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CompRef, DynamicViewDirective, DynamicViewModule, StringRef, TeleportDirective, TeleportModule, TeleportOutletDirective, TplRef, ViewService, getViewRef, injectViewContext, isComponent, isString, isTemplateRef };\n//# sourceMappingURL=ngneat-overview.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}